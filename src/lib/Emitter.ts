import { basename, resolve } from "path";

import { ESLint } from "eslint";
import { ts } from "ts-morph";

import { Content } from "./Content";
import { Config } from "./Config";

const {
  createArrayLiteralExpression,
  createAsExpression,
  createCallExpression,
  createIdentifier,
  createImportClause,
  createImportDeclaration,
  createIndexedAccessTypeNode,
  createKeywordTypeNode,
  createModifier,
  createNoSubstitutionTemplateLiteral,
  createNull,
  createObjectLiteralExpression,
  createPropertyAssignment,
  createStringLiteral,
  createToken,
  createTypeAliasDeclaration,
  createTypeQueryNode,
  createTypeReferenceNode,
  createVariableDeclaration,
  createVariableDeclarationList,
  createVariableStatement,
} = ts.factory;

const {
  SyntaxKind,
  createSourceFile,
  createPrinter,
  NodeFlags,
  ScriptTarget,
  EmitHint,
} = ts;

const createAsConst = (expression: ts.Expression): ts.Expression =>
  createAsExpression(expression, createTypeReferenceNode(`const`));

const createJsonAsConst = (json: string): ts.Expression =>
  createAsConst(ts.parseJsonText(``, json).statements[0].expression);

const createContentInitializerExpression = (
  { collection, data, location, slug, locale, raw }: Content,
  loaderIdentifier: ts.Identifier,
): ts.Expression =>
  createAsConst(
    createObjectLiteralExpression(
      [
        createPropertyAssignment(`collection`, createStringLiteral(collection)),
        createPropertyAssignment(`location`, createStringLiteral(location)),
        createPropertyAssignment(`slug`, createStringLiteral(slug)),
        createPropertyAssignment(
          `locale`,
          typeof locale === `string`
            ? createStringLiteral(locale)
            : createNull(),
        ),
        createPropertyAssignment(
          `raw`,
          typeof raw === `string`
            ? createNoSubstitutionTemplateLiteral(raw)
            : createNull(),
        ),
        createPropertyAssignment(
          `data`,
          createJsonAsConst(JSON.stringify(data, null, 2)),
        ),
        createPropertyAssignment(
          `Component`,
          createCallExpression(loaderIdentifier, undefined, [
            createCallExpression(
              createToken(SyntaxKind.ImportKeyword) as ts.Expression,
              undefined,
              [createStringLiteral(`./${location}`)],
            ),
          ]),
        ),
      ],
      true,
    ),
  );

const createContentoutSourceRaw = (
  config: Config,
  contents: Content[],
): string => {
  const loaderIdentifier = createIdentifier(`load`);
  const loaderImportStatement = createImportDeclaration(
    undefined,
    undefined,
    createImportClause(false, loaderIdentifier, undefined),
    createStringLiteral(config.loader),
  );

  const contentsIdentifier = createIdentifier(`contents`);

  const contentsIntializerExpression = createAsConst(
    createArrayLiteralExpression(
      contents.map((content) =>
        createContentInitializerExpression(content, loaderIdentifier),
      ),
      true,
    ),
  );

  const contentsDeclarationStatement = createVariableStatement(
    [createModifier(SyntaxKind.ExportKeyword)],
    createVariableDeclarationList(
      [
        createVariableDeclaration(
          contentsIdentifier,
          undefined,
          undefined,
          contentsIntializerExpression,
        ),
      ],
      NodeFlags.Const,
    ),
  );

  const contentTypeIdentifier = createIdentifier(`Content`);

  const contentTypeDeclaration = createTypeAliasDeclaration(
    undefined,
    [createModifier(SyntaxKind.ExportKeyword)],
    contentTypeIdentifier,
    undefined,
    createIndexedAccessTypeNode(
      createTypeQueryNode(contentsIdentifier),
      createKeywordTypeNode(SyntaxKind.NumberKeyword),
    ),
  );

  const sourceFile = createSourceFile(
    basename(config.indexFile),
    ``,
    ScriptTarget.Latest,
  );
  const printer = createPrinter();

  const printNodeStatement = (node: ts.Node): string =>
    `${printer.printNode(EmitHint.Unspecified, node, sourceFile)};`;

  return [
    `/** This file was automatically generated by netlify-cms-toolkit **/`,
    `/** Any changes will be overwritten, do not edit it!             **/`,
    printNodeStatement(loaderImportStatement),
    ``,
    printNodeStatement(contentsDeclarationStatement),
    ``,
    printNodeStatement(contentTypeDeclaration),
  ].join(`\n`);
};

export const createContentIndexFileSource = async (
  config: Config,
  contents: Content[],
): Promise<string> => {
  const rawSource = createContentoutSourceRaw(config, contents);

  const eslint = new ESLint({
    fix: true,
    overrideConfigFile: config.eslintrc,
  });

  const [result] = await eslint.lintText(rawSource, {
    filePath: resolve(config.cwd, config.indexFile),
  });

  if (!result.output) {
    const fmt = await eslint.loadFormatter();
    const message = fmt.format([result]);
    throw new Error(message);
  }

  return result.output;
};
